$ Puzzle Machinarium
$
$ This puzzle is from the Computer Game Machinarium and is played on a 
$ square n x n grid. The user puts a token on a field of the grid and tries to
$ touch upon every single location in the grid. 
$ There are black spots on the grid, where the token cant move to.
$ The token cant revisit a field.
$ The token can only move horizontally and vertically.
$
$ by 150001088

language ESSENCE' 1.0

given initial_grid: matrix indexed by [int(1..p), int(1..p)] of int(0, 1)

$ maximum number of moves in a clear field
letting n be p**2
$ number of free fields:
letting free be n-sum(flatten(initial_grid))
$ find the positions of the token
find numberMatrix : matrix indexed by [int(1..p), int(1..p)] of int(0..free)

such that
forAll i : int(1..p) .
	forAll j : int(1..p) .  
			initial_grid[i,j] = 0 -> numberMatrix[i,j]!=0 /\ 
			(numberMatrix[i+1,j] = numberMatrix[i,j] +1 \/ 
			numberMatrix[i,j+1] = numberMatrix[i,j] +1 \/ 
			numberMatrix[i,j]=free \/ 
			numberMatrix[i-1,j] = numberMatrix[i,j] +1 \/ 
			numberMatrix[i,j-1] = numberMatrix[i,j] +1),
forAll i : int(1..p) .
	forAll j : int(1..p) .  
		initial_grid[i,j] = 1 -> numberMatrix[i,j]=0,
$forAll i : int(1..p) .
$	forAll j : int(1..p) .  
$		initial_grid[i,j] = 0 -> numberMatrix[i,j] != 0 /\
$		(
$		(numberMatrix[i+1,j] = numberMatrix[i,j] +1 /\ numberMatrix[i-1,j] = numberMatrix[i,j] - 1 ) \/ 
$		(numberMatrix[i,j+1] = numberMatrix[i,j] +1 /\ numberMatrix[i,j-1] = numberMatrix[i,j] -1 ) \/
$		numberMatrix[i,j]=free \/ 
$		(numberMatrix[i-1,j] = numberMatrix[i,j] +1 /\ numberMatrix[i+1,j] = numberMatrix[i,j] -1 ) \/
$		(numberMatrix[i,j-1] = numberMatrix[i,j] +1 /\ numberMatrix[i,j+1] = numberMatrix[i,j] -1) \/
$		(numberMatrix[i,j-1] = numberMatrix[i,j] +1 /\ numberMatrix[i,j+1] < numberMatrix[i,j] -1 /\ (numberMatrix[i-1,j] = numberMatrix[i,j] -1 \/ numberMatrix[i+1,j] = numberMatrix[i,j] -1)) \/
$		(numberMatrix[i,j+1] = numberMatrix[i,j] +1 /\ numberMatrix[i,j-1] < numberMatrix[i,j] -1 /\ (numberMatrix[i-1,j] = numberMatrix[i,j] -1 \/ numberMatrix[i+1,j] = numberMatrix[i,j] -1)) \/
$		(numberMatrix[i-1,j] = numberMatrix[i,j] +1 /\ numberMatrix[i+1,j] < numberMatrix[i,j] -1 /\ (numberMatrix[i,j-1] = numberMatrix[i,j] -1 \/ numberMatrix[i,j+1] = numberMatrix[i,j] -1)) \/
$		(numberMatrix[i+1,j] = numberMatrix[i,j] +1 /\ numberMatrix[i-1,j] < numberMatrix[i,j] -1 /\ (numberMatrix[i,j-1] = numberMatrix[i,j] -1 \/ numberMatrix[i,j+1] = numberMatrix[i,j] -1)) \/
$		((i=p \/ j = p \/ (i=1 /\ j=1)) /\ (numberMatrix[i+1,j] = numberMatrix[i,j] +1 \/numberMatrix[i,j+1] = numberMatrix[i,j] +1 \/numberMatrix[i-1,j] = numberMatrix[i,j] +1 \/ numberMatrix[i,j-1] = numberMatrix[i,j] +1))),

forAll i : int(1..p) . 
	forAll j : int(1..p) .
		(numberMatrix[i+1,j] = numberMatrix[i,j] +1 /\ numberMatrix[i-1,j] = numberMatrix[i,j] -1) \/
		(numberMatrix[i-1,j] = numberMatrix[i,j] +1 /\ numberMatrix[i+1,j] = numberMatrix[i,j] -1) \/
 		(numberMatrix[i,j+1] = numberMatrix[i,j] +1 /\ numberMatrix[i,j-1] = numberMatrix[i,j] -1) \/ 
		(numberMatrix[i,j-1] = numberMatrix[i,j] +1 /\ numberMatrix[i,j+1] = numberMatrix[i,j] -1) \/ 

		(numberMatrix[i,j-1] = numberMatrix[i,j] -1 /\ numberMatrix[i,j+1] < numberMatrix[i,j] -1 /\ (numberMatrix[i-1,j] = numberMatrix[i,j] +1 \/ numberMatrix[i+1,j] = numberMatrix[i,j] +1)) \/
		(numberMatrix[i,j+1] = numberMatrix[i,j] -1 /\ numberMatrix[i,j-1] < numberMatrix[i,j] -1 /\ (numberMatrix[i-1,j] = numberMatrix[i,j] +1 \/ numberMatrix[i+1,j] = numberMatrix[i,j] +1)) \/
		(numberMatrix[i-1,j] = numberMatrix[i,j] -1 /\ numberMatrix[i+1,j] < numberMatrix[i,j] -1 /\ (numberMatrix[i,j-1] = numberMatrix[i,j] +1 \/ numberMatrix[i,j+1] = numberMatrix[i,j] +1)) \/
		(numberMatrix[i+1,j] = numberMatrix[i,j] -1 /\ numberMatrix[i-1,j] < numberMatrix[i,j] -1 /\ (numberMatrix[i,j-1] = numberMatrix[i,j] +1 \/ numberMatrix[i,j+1] = numberMatrix[i,j] +1)) \/

		numberMatrix[i,j]=free \/ numberMatrix[i,j]=1 \/ (i=p /\ j=p)  \/ (i=1 /\ j=p)  \/ (i=p /\ j=1) \/ (i=1 /\ j=1),



$forAll i : int(1..p) .
$	forAll j : int(1..p) .
$		!(
$		(numberMatrix[i+1,j] > numberMatrix[i,j] +1 /\ numberMatrix[i-1,j] = numberMatrix[i,j] -1)/\
$		(numberMatrix[i-1,j] > numberMatrix[i,j] +1 /\ numberMatrix[i+1,j] = numberMatrix[i,j] -1)/\
$		(numberMatrix[i,j-1] > numberMatrix[i,j] +1 /\ numberMatrix[i,j+1] = numberMatrix[i,j] -1)/\
$		(numberMatrix[i,j+1] > numberMatrix[i,j] +1 /\ numberMatrix[i,j-1] = numberMatrix[i,j] -1)
$		),
$goal: define that I should not have a number more than one bigger when the previous is one smaller
alldifferent_except(flatten(numberMatrix), 0)
